# lab7实验报告

### 计25班 姚鑫 2012011360

## 练习0
使用`SourceGear DiffMerge`工具进行比较和合并。对lab1中`trap.c`进行了进一步的修改。


## 练习1
内核级信号量由数据结构`semaphore_t`定义的，基本的P操作`down`和V操作`up`分别由函数`__down`和`__up`实现。

其成员变量`value`表示当前剩余资源数，`wait_queue`表示信号量相应的等待队列。

---

如果要实现用户态信号量机制，需要通过系统调用的方法。

可以新增三个系统调用`sys_sem`、`sys_up`和`sys_down`分别用来新建信号量、申请资源和释放资源。
在相应的中断处理中，调用相应的内核态函数。

---


## 练习2
管程由如下数据结构定义：
```
typedef struct monitor{
    semaphore_t mutex;      //mutex实现了一个二值信号量(初始化时value值设为1)，用于确保每次只有一个进程进入管程
    semaphore_t next;       //用于唤醒由于发出signal操作而睡眠的进程
    int next_count;         //上述睡眠进程的个数
    condvar_t *cv;          //管程中的条件变量
} monitor_t;
```
条件变量由如下数据结构定义：
```
typedef struct condvar{
    semaphore_t sem;        //让发出wait操作的进程睡眠，让发出signal操作的进程通过该信号量唤醒睡眠的进程
    int count;              //表示等待在该条件变量上的睡眠进程个数
    monitor_t * owner;      //表示该条件变量的宿主是哪个管程
} condvar_t;
```
管程的两个重要成员函数：
	1. `cond_wait`：将该进程挂起并进行等待，直到该进程等待的条件为真，为真后程序会自动唤醒睡眠中的进程；
	2. `cond_signal`：条件为真，可以唤醒等待该条件的进程。
按照注释提示完成上述两个函数的实现。

---

哲学家就餐问题：
	申请叉子时，如果发现条件不能满足，那么进入等待，条件为（本人相邻的人都不在吃）。 
	释放叉子时，首先把自己的状态设置为不在吃，然后试图唤醒相邻的人。如果可以唤醒，那么让它醒来，并让其结束申请过程。
这些步骤都需要在管程中进行，确保资源使用的互斥性。

---

如果要实现用户态的条件变量机制，可以参考练习1种用户态的信号量机制的实现，即通过系统调用的方法。
